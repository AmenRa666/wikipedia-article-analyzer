<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.10/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.10/ http://www.mediawiki.org/xml/export-0.10.xsd" version="0.10" xml:lang="en">
  <siteinfo>
    <sitename>Wikipedia</sitename>
    <dbname>enwiki</dbname>
    <base>https://en.wikipedia.org/wiki/Main_Page</base>
    <generator>MediaWiki 1.28.0-wmf.22</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Media</namespace>
      <namespace key="-1" case="first-letter">Special</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Talk</namespace>
      <namespace key="2" case="first-letter">User</namespace>
      <namespace key="3" case="first-letter">User talk</namespace>
      <namespace key="4" case="first-letter">Wikipedia</namespace>
      <namespace key="5" case="first-letter">Wikipedia talk</namespace>
      <namespace key="6" case="first-letter">File</namespace>
      <namespace key="7" case="first-letter">File talk</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">MediaWiki talk</namespace>
      <namespace key="10" case="first-letter">Template</namespace>
      <namespace key="11" case="first-letter">Template talk</namespace>
      <namespace key="12" case="first-letter">Help</namespace>
      <namespace key="13" case="first-letter">Help talk</namespace>
      <namespace key="14" case="first-letter">Category</namespace>
      <namespace key="15" case="first-letter">Category talk</namespace>
      <namespace key="100" case="first-letter">Portal</namespace>
      <namespace key="101" case="first-letter">Portal talk</namespace>
      <namespace key="108" case="first-letter">Book</namespace>
      <namespace key="109" case="first-letter">Book talk</namespace>
      <namespace key="118" case="first-letter">Draft</namespace>
      <namespace key="119" case="first-letter">Draft talk</namespace>
      <namespace key="446" case="first-letter">Education Program</namespace>
      <namespace key="447" case="first-letter">Education Program talk</namespace>
      <namespace key="710" case="first-letter">TimedText</namespace>
      <namespace key="711" case="first-letter">TimedText talk</namespace>
      <namespace key="828" case="first-letter">Module</namespace>
      <namespace key="829" case="first-letter">Module talk</namespace>
      <namespace key="2300" case="first-letter">Gadget</namespace>
      <namespace key="2301" case="first-letter">Gadget talk</namespace>
      <namespace key="2302" case="case-sensitive">Gadget definition</namespace>
      <namespace key="2303" case="case-sensitive">Gadget definition talk</namespace>
      <namespace key="2600" case="first-letter">Topic</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>Stdarg.h</title>
    <ns>0</ns>
    <id>7762594</id>
    <revision>
      <id>731466064</id>
      <parentid>716050535</parentid>
      <timestamp>2016-07-25T15:05:39Z</timestamp>
      <contributor>
        <username>Bender235</username>
        <id>88026</id>
      </contributor>
      <minor/>
      <comment>/* Type safety */clean up; http-&gt;https (see [[WP:VPR/Archive 127#RfC: Should we convert existing Google and Internet Archive links to HTTPS?|this RfC]]) using [[Project:AWB|AWB]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="10670">{{manual|date=October 2013}}

{{C Standard Library}}
{{lowercase|title=stdarg.h}}

'''&lt;code&gt;stdarg.h&lt;/code&gt;''' is a header in the [[C standard library]] of the [[C programming language]] that allows functions to accept an indefinite number of arguments.&lt;ref&gt;{{cite web | url=http://www.opengroup.org/onlinepubs/009695399/basedefs/stdarg.h.html | title=IEEE Std 1003.1 &lt;code&gt;stdarg.h&lt;/code&gt; | accessdate=2009-07-04}}&lt;/ref&gt; It provides facilities for stepping through a list of function arguments of unknown number and type.  [[C++]] provides this functionality in the header &lt;code&gt;cstdarg&lt;/code&gt;.

The contents of &lt;code&gt;stdarg.h&lt;/code&gt; are typically used in [[variadic function]]s, though they may be used in other functions (for example, &lt;code&gt;[[vprintf]]&lt;/code&gt;) called by variadic functions.

==Declaring variadic functions==

[[Variadic functions]] are functions which may take a variable number of arguments and are declared with an [[ellipsis]] in place of the last parameter. An example of such a function is &lt;code&gt;[[printf]]&lt;/code&gt;. A typical declaration is

&lt;source lang=&quot;c&quot;&gt;
int check(int a, double b, ...);
&lt;/source&gt;

Variadic functions must have at least one named parameter, so, for instance,

&lt;source lang=&quot;c&quot;&gt;
char *wrong(...);
&lt;/source&gt;

is not allowed in C. (In C++, such a declaration is permitted) In C, a comma must precede the ellipsis; in C++, it is optional.

==Defining variadic functions==
The same syntax is used in a definition:

&lt;source lang=c&gt;
long func(char, double, int, ...);

long func(char a, double b, int c, ...)
{
    /* ... */
}
&lt;/source&gt;

An ellipsis may not appear in old-style function definitions.

==stdarg.h types==

{|class=&quot;wikitable&quot;
|-
! Name !! Description !! Compatibility
|-
|&lt;code&gt;[http://en.cppreference.com/w/cpp/utility/variadic/va_list va_list]&lt;/code&gt; || type for iterating arguments || [[C89 (C version)|C89]]
|}

==stdarg.h macros==

{|class=&quot;wikitable&quot;
|-
! Name !! Description !! compatibility
|-
|&lt;code&gt;[http://en.cppreference.com/w/cpp/utility/variadic/va_start va_start]&lt;/code&gt; || Start iterating arguments with a &lt;code&gt;va_list&lt;/code&gt; || C89
|-
|&lt;code&gt;[http://en.cppreference.com/w/cpp/utility/variadic/va_arg va_arg]&lt;/code&gt; || Retrieve an argument || C89
|-
|&lt;code&gt;[http://en.cppreference.com/w/cpp/utility/variadic/va_end va_end]&lt;/code&gt; || Free a &lt;code&gt;va_list&lt;/code&gt; || C89
|-
|&lt;code&gt;[http://en.cppreference.com/w/cpp/utility/variadic/va_copy va_copy]&lt;/code&gt; || Copy contents of one &lt;code&gt;va_list&lt;/code&gt; to another || [[C99]]
|}

==Accessing the arguments==

To access the unnamed arguments, one must declare a variable of type &lt;code&gt;va_list&lt;/code&gt; in the variadic function. The macro &lt;code&gt;va_start&lt;/code&gt; is then called with two arguments: the first is the variable declared of the type &lt;code&gt;va_list&lt;/code&gt;, the second is the name of the last named parameter of the function. After this, each invocation of the &lt;code&gt;va_arg&lt;/code&gt; macro yields the next argument. The first argument to &lt;code&gt;va_arg&lt;/code&gt; is the &lt;code&gt;va_list&lt;/code&gt; and the second is the type of the next argument passed to the function. Finally, the &lt;code&gt;va_end&lt;/code&gt; macro must be called on the &lt;code&gt;va_list&lt;/code&gt; before the function returns. (It is not required to read in all the arguments.)

[[C99]] provides an additional macro, &lt;code&gt;va_copy&lt;/code&gt;, which can duplicate the state of a &lt;code&gt;va_list&lt;/code&gt;. The macro invocation &lt;code&gt;va_copy(va2, va1)&lt;/code&gt; copies &lt;code&gt;va1&lt;/code&gt; into &lt;code&gt;va2&lt;/code&gt;.

There is no mechanism defined for determining the number or types of the unnamed arguments passed to the function. The function is simply required to know or determine this somehow, the means of which vary.  Common conventions include:
* Use of a &lt;code&gt;[[printf]]&lt;/code&gt; or &lt;code&gt;[[scanf]]&lt;/code&gt;-like format string with embedded specifiers that indicate argument types.
* A [[sentinel value]] at the end of the variadic arguments.
* A count argument indicating the number of variadic arguments.

===Passing unnamed arguments to other calls===
Because the size of the unnamed argument list is generally unknown (the calling conventions employed by most compilers do not permit determining the size of the unnamed argument block pointed by &lt;code&gt;va_list&lt;/code&gt; inside the receiving function), there is also no reliable generic way to forward the unnamed arguments into another variadic function. Even where determining the size of the argument list is possible by indirect means (for example, by parsing the format string of &lt;code&gt;fprintf()&lt;/code&gt;), there is no portable way to pass the dynamically determined number of arguments into the inner variadic call, as the number and size of arguments passed into such calls must generally be known at compile time. To some extent, this restriction can be relaxed by employing [[variadic macro]]s instead of variadic functions. Additionally, most standard library procedures provide &lt;code&gt;v&lt;/code&gt;-prefixed alternative versions which accept a ''reference'' to the unnamed argument list (i.e. an initialized &lt;code&gt;va_list&lt;/code&gt; variable) instead of the unnamed argument list itself. For example, &lt;code&gt;vfprintf()&lt;/code&gt; is an alternate version of &lt;code&gt;fprintf()&lt;/code&gt; expecting a &lt;code&gt;va_list&lt;/code&gt; instead of the actual unnamed argument list. A user-defined variadic function can therefore initialize a &lt;code&gt;va_list&lt;/code&gt; variable using &lt;code&gt;va_start&lt;/code&gt; and pass it to an appropriate standard library function, in effect passing the unnamed argument list by reference instead of doing it by value. Because there is no reliable way to pass unnamed argument lists by value in C, providing variadic [[Application programming interface|API]] functions without also providing equivalent functions accepting &lt;code&gt;va_list&lt;/code&gt; instead is considered a bad programming practice.

==Type safety==

Some C implementations provide C extensions that allow the compiler to check for the proper use of format strings and sentinels.  Barring these extensions, the compiler usually cannot check whether the unnamed arguments passed are of the type the function expects, or convert them to the required type. Therefore, care should be taken to ensure correctness in this regard, since [[undefined behavior]] results if the types do not match. For example, if the expected type is &lt;code&gt;int *&lt;/code&gt;, then a null pointer should be passed as &lt;code&gt;(int *)NULL&lt;/code&gt;. Writing just &lt;code&gt;NULL&lt;/code&gt; would result in an argument of type either &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;void *&lt;/code&gt;, neither of which is correct. Another consideration is the default argument [[Type conversion#Type promotion in C-like languages|promotions]] applied to the unnamed arguments. A &lt;code&gt;float&lt;/code&gt; will automatically be promoted to a &lt;code&gt;double&lt;/code&gt;. Likewise, arguments of types narrower than an &lt;code&gt;int&lt;/code&gt; will be promoted to &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;unsigned int&lt;/code&gt;. The function receiving the unnamed arguments must expect the promoted type.

[[GNU Compiler Collection|GCC]] has an extension that checks the passed arguments:

{{quote|
&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;format(archetype, string-index, first-to-check)&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The format attribute specifies that a function takes &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt; or &lt;code&gt;strfmon&lt;/code&gt; style arguments which should be type-checked against a format string. For example, the declaration:

&lt;source lang=&quot;c&quot;&gt;
extern int
my_printf (void *my_object, const char *my_format, ...)
      __attribute__ ((format (printf, 2, 3)));
&lt;/source&gt;

causes the compiler to check the arguments in calls to &lt;code&gt;my_printf&lt;/code&gt; for consistency with the &lt;code&gt;printf&lt;/code&gt; style format string argument &lt;code&gt;my_format&lt;/code&gt;.&lt;/dd&gt;&lt;/dl&gt;|{{cite web | title = 5.27 Extensions to the C Language Family - Declaring Attributes of Functions | url=https://gcc.gnu.org/onlinedocs/gcc-4.3.2/gcc/Function-Attributes.html#Function-Attributes | accessdate = 2009-01-03 }}}}

==Example==

&lt;source lang=c&gt;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

/* print all args one at a time until a negative argument is seen;
   all args are assumed to be of int type */
void printargs(int arg1, ...)
{
  va_list ap;
  int i;

  va_start(ap, arg1); 
  for (i = arg1; i &gt;= 0; i = va_arg(ap, int))
    printf(&quot;%d &quot;, i);
  va_end(ap);
  putchar('\n');
}

int main(void)
{
   printargs(5, 2, 14, 84, 97, 15, -1, 48, -1);
   printargs(84, 51, -1);
   printargs(-1);
   printargs(1, -1);
   return 0;
}
&lt;/source&gt;

This program yields the output:

&lt;pre&gt;
5 2 14 84 97 15
84 51

1
&lt;/pre&gt;

To call other var args functions from within your function (such as sprintf) you need to use the var arg version of the function (vsprintf in this example):
&lt;source lang=c&gt;
void MyPrintf(const char *format, ...)
{
  va_list args;
  char buffer[BUFSIZ];

  va_start(args, format);
  vsnprintf(buffer, sizeof buffer, format, args);
  va_end(args);
  FlushFunnyStream(buffer);
}
&lt;/source&gt;

==varargs.h==
Outdated versions of [[POSIX]] defined the legacy header &lt;code&gt;varargs.h&lt;/code&gt;, which dates from before the standardization of C and provides functionality similar to &lt;code&gt;stdarg.h&lt;/code&gt;. This header is part of neither ISO C nor POSIX. The file, as defined in the second version of the [[Single UNIX Specification]], simply contains all of the functionality of C89 &lt;code&gt;stdarg.h&lt;/code&gt;, with the exceptions that: it cannot be used in standard C new-style definitions; you may choose not to have a given argument (standard C requires at least one argument); and the way it works is different—in standard C, one would write:

&lt;source lang=&quot;c&quot;&gt;
#include &lt;stdarg.h&gt;

int summate(int n, ...)
{
    va_list ap;
    int i = 0;

    va_start(ap, n);
    for (; n; n--)
        i += va_arg(ap, int);
    va_end(ap);
    return i;
}
&lt;/source&gt;

and call with

&lt;source lang=&quot;c&quot;&gt;
summate(0);
summate(1, 2);
summate(4, 9, 2, 3, 2);
&lt;/source&gt;

With &lt;code&gt;varargs.h&lt;/code&gt;, the function would be:

&lt;source lang=&quot;c&quot;&gt;
#include &lt;varargs.h&gt;

summate(n, va_alist)
    va_dcl /* no semicolon here! */
{
    va_list ap;
    int i = 0;

    va_start(ap);
    for (; n; n--)
        i += va_arg(ap, int);
    va_end(ap);
    return i;
}
&lt;/source&gt;

and is called the same way.

&lt;code&gt;varargs.h&lt;/code&gt; requires old-style function definitions because of the way the implementation works.&lt;ref&gt;{{cite web | url=http://www.opengroup.org/onlinepubs/007908799/xsh/varargs.h.html | title=Single UNIX Specification &lt;code&gt;varargs.h&lt;/code&gt; | accessdate=2007-08-01}}&lt;/ref&gt; Conversely, it is not possible to mix old-style function definitions with &lt;code&gt;stdarg.h&lt;/code&gt;.

==References==
{{Reflist}}

{{CProLang|state=expanded}}

[[Category:Articles with example C code]]
[[Category:C standard library headers]]</text>
      <sha1>38fuxlbsykqama9nmdfwlejdggswk2s</sha1>
    </revision>
  </page>
</mediawiki>
